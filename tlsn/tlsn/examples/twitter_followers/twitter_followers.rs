use std::{str, time::Duration};

use elliptic_curve::pkcs8::DecodePublicKey;

use tlsn_core::proof::{SessionProof, TlsProof};

use tlsn_core::transcript::{
    RedactedTranscript
};

use serde::Deserialize;
use serde_json::Value; // Or replace this with your custom struct.

/// A simple verifier which reads a proof generated by `simple_prover.rs` from "proof.json", verifies
/// it and prints the verified data to the console.

struct FollowerCount {
    screen_name: String,
    follower_count: u64,
}

// This needs to be done differently for when we do verification on Cartesi!
fn import_proof_file(filepath: &str) -> Result<TlsProof, Box<dyn std::error::Error>> {
   // Deserialize the proof
    let auth_proof = std::fs::read_to_string(filepath).unwrap();
    let auth_proof: TlsProof = serde_json::from_str(auth_proof.as_str()).unwrap();

    Ok(auth_proof)
}

fn read_verify_proof(filepath: &str) -> Result<(RedactedTranscript, RedactedTranscript), Box<dyn std::error::Error>> {
    let TlsProof {
        // The session proof establishes the identity of the server and the commitments
        // to the TLS transcript.
        session,
        // The substrings proof proves select portions of the transcript, while redacting
        // anything the Prover chose not to disclose.
        substrings,
    } = import_proof_file(filepath).unwrap();

    // Verify the session proof against the Notary's public key
    //
    // This verifies the identity of the server using a default certificate verifier which trusts
    // the root certificates from the `webpki-roots` crate.
    session
        .verify_with_default_cert_verifier(notary_pubkey())?;

    let SessionProof {
        // The session header that was signed by the Notary is a succinct commitment to the TLS transcript.
        header,
        // This is the session_info, which contains the server_name, that is checked against the
        // certificate chain shared in the TLS handshake.
        session_info,
        ..
    } = session;

    // The time at which the session was recorded
    let time = chrono::DateTime::UNIX_EPOCH + Duration::from_secs(header.time());

    // Verify the substrings proof against the session header.
    //
    // This returns the redacted transcripts
    let (mut sent, mut recv) = substrings.verify(&header)?;

    // Replace the bytes which the Prover chose not to disclose with 'X'
    sent.set_redacted(b'X');
    recv.set_redacted(b'X');

    if false {
        dbg!("-------------------------------------------------------------------");
        dbg!(
            "Successfully verified that the bytes below came from a session with {:?} at {}.",
            session_info.server_name, time
        );
        dbg!("Note that the bytes which the Prover chose not to disclose are shown as X.");
        dbg!();
        dbg!("Bytes sent:");
        dbg!();
        dbg!("{}", String::from_utf8(sent.data().to_vec()).unwrap());
        dbg!();
        dbg!("Bytes received:");
        dbg!();
        dbg!("{}", String::from_utf8(recv.data().to_vec()).unwrap());
        dbg!("-------------------------------------------------------------------");
    }

    Ok((sent, recv))
}


fn check_prefix(input_str: String, prefix_str: String) -> Result<(), Box<dyn std::error::Error>> {
    if input_str.trim_start().starts_with(&prefix_str) {
        Ok(())
    } else {
        Err(Box::from(format!(
            "The requested URL prefix '{}' was not found in the input header: '{}'",
            prefix_str, input_str
        )))
    }
}

fn check_contains(input_str: String, sub_str: String) -> Result<(), Box<dyn std::error::Error>> {
    if input_str.contains(&sub_str) {
        Ok(())
    } else {
        Err(Box::from(format!(
            "The requested URL substring '{}' was not found in the input header: '{}'",
            sub_str, input_str
        )))
    }
}

fn deserialize_json(input_str: String) -> Result<Value, Box<dyn std::error::Error>> {
    // Get the last line from the input string
    if let Some(last_line) = input_str.lines().last() {
        // Deserialize the last line as JSON
        let json_value: Value = serde_json::from_str(last_line)?;
        Ok(json_value)
    } else {
        Err("No lines found in input".into())
    }
}

fn verify_twitter_followers(target_username: String) -> Result<FollowerCount, Box<dyn std::error::Error>> {
    let auth_str: &str = "../../proof/auth_proof.json";
    let auth_proof = read_verify_proof(auth_str);
    let (auth_proof_sent, auth_proof_recv) = auth_proof?;

    let user_str: &str = "../../proof/user_proof.json";
    let user_proof = read_verify_proof(user_str);
    let (user_proof_sent, user_proof_recv) = user_proof?;

    // First check that the URLs called are the correct ones.

    check_prefix(String::from_utf8(auth_proof_sent.data().to_vec()).unwrap(), 
                "GET https://api.x.com/1.1/account/settings.json".to_string())?;
    check_prefix(String::from_utf8(user_proof_sent.data().to_vec()).unwrap(), 
                "GET https://x.com/i/api/graphql/".to_string())?;
    check_contains(String::from_utf8(user_proof_sent.data().to_vec()).unwrap(), 
                format!("UserByScreenName?variables=%7B%22screen_name%22%3A%22{}", target_username))?;

    let auth_json_obj = deserialize_json(String::from_utf8(auth_proof_recv.data().to_vec()).unwrap())?;

    if let Some(screen_name) = auth_json_obj.get("screen_name").and_then(|x| x.as_str()) {
        if screen_name.to_lowercase() != target_username.to_lowercase() {
            return Err(Box::from(format!("Incorrect screen name caught from auth proof: {}", screen_name)));
        }
    } else {
        return Err(Box::from(format!("Auth Json object did not contain screen name: {}", auth_json_obj)));
    }


    let user_json_obj = deserialize_json(String::from_utf8(user_proof_recv.data().to_vec()).unwrap())?;

    let unwrapped_user_data = user_json_obj.get("data").and_then(|x| x.get("user")).and_then(|x| x.get("result")).and_then(|x| x.get("legacy")).unwrap();

    if let Some(screen_name) = unwrapped_user_data.get("screen_name").and_then(|x| x.as_str()) {
        if screen_name.to_lowercase() != target_username.to_lowercase() {
            return Err(Box::from(format!("Incorrect screen name caught from user proof: {}", screen_name)));
        }
    } else {
        return Err(Box::from(format!("User Json object did not contain screen name: {}", auth_json_obj)));
    }

    let follower_count = unwrapped_user_data
        .get("followers_count").ok_or("Follower count not found")?
        .as_u64().ok_or("Invalid cast to u64")?;

    Ok(FollowerCount {
        screen_name: target_username,
        follower_count: follower_count
    })
}


fn main() {
    let FollowerCount {
        screen_name, 
        follower_count,
    } = verify_twitter_followers("mattbeton".to_string()).unwrap();

    println!("Finished with OK! {}, {}", screen_name, follower_count);
}

/// Returns a Notary pubkey trusted by this Verifier
fn notary_pubkey() -> p256::PublicKey {
    let pem_file = str::from_utf8(include_bytes!(
        "../../../keys/public_notary.pub"
    ))
    .unwrap();
    p256::PublicKey::from_public_key_pem(pem_file).unwrap()
}
